import sys
import re
import matplotlib
import os
try:
    matplotlib.use('tkagg')
except:
    if os.name == 'nt':
        print("skipping gitk...")
    else:
        print("ERROR: issue with gitk import of matplotlib for X11 over ssh")
        sys.exit(-1)
import matplotlib.pyplot as plt

def miniBatchVals(results_dict, line):
    if "basic_session_run_hooks" in line:
        if "loss = " in line and "step = " in line and "sec" in line:
            results_dict["loss_table"].append(float(re.search("loss = (.*),", line).group(1)))
            if len(results_dict["step_dur_table"]) < 1000:
                results_dict["step_dur_table"].append(results_dict["batch_size"]*results_dict["log_step_count"]/float(re.search("step =.*(\d+\.\d+)", line).group(1)))
        if "train_accuracy = " in line:
            results_dict["acc_table"].append(float(re.search("train_accuracy = (\d+\.\d+)", line).group(1)))

def getData(set_of_logs):
    for results_dict in set_of_logs:
        with open(results_dict["file_name"], "r") as fr:
            for line in fr:
                miniBatchVals(results_dict, line)

def getLogStepCount(file_name):
    step_number = 0
    found = False
    with open(file_name, "r") as fr:
        for line in fr:
            if "basic_session_run_hooks" in line and "step = " in line and "loss = " in line and "sec" in line:
                if not found:
                    found = True
                    step_number = int(re.search("step =\s(.*)\s\(", line).group(1))
                else:
                    next_step_number = int(re.search("step =\s(.*)\s\(", line).group(1))
                    return next_step_number - step_number

def plotSimple(ax, x_vals, y_vals, plot_label):
    ax.plot(x_vals, y_vals, label=plot_label)

def plotHistogram(ax, x_vals, y_vals, plot_label):
    ax.hist(y_vals, label=plot_label, bins=50)

def plotGraph(plot_func, set_of_logs, dict_entry, layout, title, xtitle, ytitle):
    ax = plt.subplot(*layout)
    for results_dict in set_of_logs:
        if dict_entry == "loss_table":
            range_start = 0
            range_end = results_dict["log_step_count"]*len(results_dict[dict_entry]) * results_dict["batch_size"]
            range_step = results_dict["log_step_count"] * results_dict["batch_size"]
        elif dict_entry == "acc_table":
            range_start = 0
            range_end = 100 * len(results_dict[dict_entry]) * results_dict["batch_size"]
            range_step = 100 * results_dict["batch_size"]
        else:
            range_start = 0
            range_end = len(results_dict[dict_entry])
            range_step = 1
        plot_func(ax,
                  range(range_start, range_end, range_step),
                  results_dict[dict_entry],
                  results_dict["file_name"].split(".")[0])
    ax.set_title(title, fontweight="bold")
    ax.set_ylabel(ytitle)
    ax.set_xlabel(xtitle)
    ax.legend()

def printInfo():
    print(
    '''
     This script plots data generated by Resnet Demo app. The data is printed by tests in the following form:
         ...
         I1212 14:52:52.425458 140131492190016 basic_session_run_hooks.py:260] loss = 8.277344, step = 1400 (1.642 sec)
         I1212 14:52:54.109468 140131492190016 basic_session_run_hooks.py:260] cross_entropy = 6.885742, learning_rate = 0.00044709316, train_accuracy = 0.0 (152.259 sec)
         I1212 14:52:54.111438 140131492190016 basic_session_run_hooks.py:260] loss = 8.28418, step = 1401 (1.686 sec)
         I1212 14:52:55.813201 140131492190016 basic_session_run_hooks.py:260] loss = 8.462891, step = 1402 (1.702 sec)
         ...
     The output of this script are 4 subplots showing: Loss, Accuracy, Epoch Loss and Epoch Accuracy. It is possible to plot
     arbitrary number of files, as long as the results format is as described above.

     Usage:
         > python plot_results_resnet50.py <batch_size_file1> <file1> <batch_size_file2> <file2> ...
    ''')
if __name__=='__main__':
    if not len(sys.argv) > 2:
        print("ERROR: Need to provide at least two params (pair of batch size and a file to plot)!")
        printInfo()
        sys.exit(-1)
    if not (len(sys.argv)-1)%2 == 0:
        print("ERROR: Need to provide even number of params (pairs of batch size and a file to plot)!")
        printInfo()
        sys.exit(-1)

    set_to_load = []
    batch_sizes = []
    for idx in range(1, len(sys.argv), 2):
        batch_size = 0
        try:
            batch_size = int(sys.argv[idx])
        except ValueError:
            print("Batch_size arg is not int: " + str(sys.argv[idx]))
            sys.exit(-1)
        file_name = str(sys.argv[idx+1])
        set_to_load.append({"file_name": file_name,
                            "loss_table" : [],
                            "acc_table": [],
                            "step_dur_table": [],
                            "batch_scaling_factor": 0,
                            "batch_size": batch_size,
                            "log_step_count": getLogStepCount(file_name)})
        batch_sizes.append(batch_size)

    getData(set_to_load)

    step_dict = {}
    min_batch_size = min(batch_sizes)
    for batch_size in batch_sizes:
        step_dict.update({batch_size: int(batch_size / min_batch_size)})
    for results_dict in set_to_load:
        results_dict["batch_scaling_factor"] = step_dict[results_dict["batch_size"]]

    # Results for all iterations
    fig = plt.figure()
    plotGraph(plotSimple, set_to_load, "loss_table", (2, 2, 1), "Loss", "Number of processed images", "Loss")
    plotGraph(plotSimple, set_to_load, "acc_table", (2, 2, 2), "Accuracy", "Number of processed images", "Accuracy")
    plotGraph(plotHistogram, set_to_load, "step_dur_table", (2, 2, 3), "IPS Histogram (first 1k iterations)", "Images Per Second", "Occurance count")
    plotGraph(plotSimple, set_to_load, "step_dur_table", (2, 2, 4), "IPS over iterations (first 1k iterations)", "Iteration number", "Number of IPS")
    plt.show()
